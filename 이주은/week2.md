# 2장 테스트
2장에서는 테스트란 무엇이며, 그 가치와 장점, 활용 전략, 스프링과의 관계를 살펴본다.

## 2.1 UserDaoTest 다시보기
### 테스트의 유용성
테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는 지를 확인해서, **만든 코드를 확신할 수 있게 해주는 작업**이다. 또한 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다.

### UserDaoTest의 특징
```
public class UserDaoTest {
	public static void main(String[] args) throws SQLException {
		ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

		UserDao dao = context.getBean("userDao", UserDao.class);

		User user = new User();
		user.setId("user);
		user.setName("백기선");
		uset.setPassword("married");

		dao.add(user);

		System.out.println(user.getId() + "등록 성공");

		User user2 = dao.get(user.getId());
		System.out.println(user2.getName());
		System.out.println(user2.getPassword());

		System.out.println(user2.getId() + "조회 성공");
	}
}
```

- 자바에서 가장 손쉽게 실행 가능 한 main() 메소드를 이용한다.
- 테스트할 대상인 UserDao 오브젝트를 가져와 메소드를 호출한다.
- 테스트에 사용할 입력 값(User 오브젝트)을 직접 코드에서 만들어 넣어준다.
- 테스트의 결과를 콘솔에 출력해준다.
- 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메시지를 출력한다.

### 웹을 통한 DAO 테스트 방법의 문제점
- 모든 레이어의 기능을 다 만들어야 테스트가 가능하다.
- 테스트에 참여하는 클래스와 코드가 너무 많아 테스트 중 에러가 나면 에러 발생 지점을 찾아내는 수고가 많이 필요하다.

### 작은 단위의 테스트
**테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다.**  `관심사의 분리`라는 원리가 여기에도 적용된다. 이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트(`Unit Test`)라고 한다. 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다.

때로는 `단위 테스트` 없이 바로 이런 긴 테스트만 하는 경우도 있다. **이때는 문제의 원인을 찾기가 매우 힘들다.**

### UserDaoTest의 문제점
- 수동 확인 작업의 번거로움
	- 콘솔에 출력된 값을 보고 확인하는 건 사람의 책임이므로 완전히 자동으로 테스트되는 방법이라 볼 수 없다.
- 실행 작업의 번거로움
	 - main()메소드가 간단히 실행된다고 하더라도 DAO가 수백 개가 된다면 메소드를 수백 번 실행하는 수고가 필요할 것이다.

## 2.2 UserDaoTest 개선

#### JUnit 테스트로 전환
1️⃣ 메소드를 public으로 선언한다.<br/>
2️⃣ 메소드에 @Test라는 애노테이션을 붙여준다.

#### 검증 코드 전환
    assertThat(user2.getName(), is(user.getName()));
   - assertThat() 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 matcher라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다. 
   - is()는 matcher의 일종으로 equals()로 비교해준다.

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit
#### 테스트 결과의 일관성
단위 테스트는 항상 일관성 있는 결과가 보장되어야 한다는 점을 잊어선 안 된다. DB에 남아 있는 데이터와 같은 외부 환경에 양향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.

#### 테스트가 이끄는 개발
테스트 코드는 마치 잘 작성된 하나의 기능정의서가 될 수 있다. 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법을 테스트 주도 개발(TDD, Test Driven Development)라고 한다.

- 테스트는 코드를 작성한 후에 가능한 빨리 실행할 수 있어야 한다. 그러려면 테스트 없이 한 번에 너무 많은 코드를 만드는 것은 좋지 않다.

### 테스트 코드 개선
JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.
> 1️⃣ 테스트 클래스에 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.<br/>
 2️⃣ 테스트 클래스의 오브젝트를 하나 만든다.<br/>
 3️⃣ @Before가 붙은 메소드가 있으면 실행한다.<br/>
 4️⃣ @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.<br/>
 5️⃣ @After가 붙은 메소드가 있으면 실행한다.<br/>
 6️⃣ 나머지 테스트 메소드에 대해 2~5번을 반복한다.<br/>
 7️⃣ 모든 테스트의 결과를 종합해서 돌려준다.<br/>

공통적인 준비 작업과 정리 작업이 필요한 경우 @Before와 @After 메소드에 이러한 작업들을 넣어두면, **Junit이 @Test가 붙은 메소드를 실행하기 전과 후에 각각 자동으로 실행해주기** 때문에 매우 편리하다.

- 서로 주고 받을 정보나 오브젝트가 있다면 인스턴스 변수를 이용해야 한다. @Before나 @After 메소드를 테스트 메소드에서 직접 호출하지 않기 때문이다.
- 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다. 테스트 클래스가 @Test 테스트 메소드를 두 개 갖고 있다면, 테스트가 실행되는 중에 JUnit은 이 클래스의 오브젝트를 두 번 만들 것이다.

- 테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스쳐 fixture라고 한다. 일반적으로 픽스쳐는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성해두면 편리하다.

픽스쳐와 @Before 메소드를 이용하여 개선한 코드이다.

    public class UserDaoTest {
    	private UserDao dao;
    	private User user1;
    	private User user2;
    	private User user3;
    
    	@Before
    	public void setUp(){
    		...
    		this.user1 = new User("lizuAg", "이주은", "spring1");
    		...
    	}

		@Test
		public void addAndGet() throws SQLException {
			...
		}
		...
    }
  <br/>
  
## 2.4 스프링 테스트 적용
테스트는 가능한 한 독립적으로 매번 새로운 오브젝트를 만들어서 사용하는 것이 원칙이다. 하지만 애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우 테스트 전체가 공유하는 오브젝트를 만들기도 한다.

    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(locations="/application.xml")
    public class UserDaoTest {
    	@Autowired
    	private ApplicationContext context;
    	...
    
    	@Before
    	public void setUp() {
    		this.dao = this.context.getBean("userDao", UserDao.class);
    		...
    	}
    
    	...
    }
#### 테스트 메소드의 컨텍스트 공유
하나의 애플리케이션 컨텍스트가 만들어져 모든 테스트 메소드에 사용된다. 반면에 Test 클래스 오브젝트는 매번 주소 값이 다르다. JUnit은 테스트 메소드를 실행할 때마다 새로운 테스트 오브젝트를 만들기 때문이다.

#### 테스트 클래스의 컨텍스트 공유
여러 개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트 클래스 사이에서도 애플리케이션을 공유하게 해준다.

#### @Autowired
@Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다. 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다.

@Autowired를 이용해 애플리케이션 컨텍스트가 갖고 있는 빈을 DI 받을 수 있다면, getBean()을 이용하는 것이 아니라, 아예 UserDao 빈을 DI 받아보자.

    public class UserDaoTest {
    	@Autowired
    		UserDao dao;
    		...
    }

+) 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다. 따라서 애플리케이션 컨텍스트에는 ApplicationContext 타입의 빈이 존재하고, DI도 가능했다.

### DI와 테스트
#### @DirtiesContext
@DirtiesContext 어노테이션은 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다. 이후에 진행되는 테스트를 위해 변경된 애플리케이션 컨텍스트는 폐기되고 새로운 애플리케이션 컨텍스트가 만들어진다.

#### 테스트를 위한 별도의 DI 설정
테스트코드에서 빈 오브젝트에 수동으로 DI하는 방법은 장점보다 단점이 더 많다. **테스트 전용 설정파일을 따로 만들어 사용하는 방법을 사용하자.**

#### DI를 이용한 테스트 방법 선택
- 항상 스프링 컨테니너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려하자.
- 복잡한 의존관계를 가진 오브젝트를 테스트해야할 경우가 있다면 스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리하다.
- 예외적인 의존관계를 강제로 구성해야하는 테스트의 경우는 @DirtiesContext 어노테이션을 잊지 말자.
<br/>

## 2.5 학습 테스트로 배우는 스프링
### 학습 테스트의 장점
1️⃣ 다양한 조건에 따른 기능을 손쉽게 확인할 수 있다.
2️⃣ 학습 테스트 코드를 개발중에 참고할 수 있다.
3️⃣ 프레임워크나 제품을 업그레이할 때 호환성 검증을 도와준다.
4️⃣ 테스트 작성에 대한 좋은 훈련이 된다.
5️⃣ 새로운 기술을 공부하는 과정이 즐거워진다.

### 버그테스트
- 버그 테스트 *bug test* 란 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말한다. 
- 버그테스트의 장점
> 1️⃣ 테스트의 완성도를 높여준다.<br/>
2️⃣ 버그의 내용을 명확하게 분석하게 해준다.<br/>
3️⃣ 기술적인 문제를 해결하는 데 도움이 된다.<br/>

## 2.6 정리
- 테스트는 자동화돼야 하고, 빠르게 실행할 수 있어야 한다.
- main() 테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다.
- 테스트 결과는 일관성이 있어야 한다. 코드의 변경 없이 환경이나 테스트 실행 순서에 따라서 결과가 달라지면 안 된다.
- 테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나쁠 수 있다.
- 코드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
- 테스트하기 쉬운 코드가 좋은 코드다.
- 테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 테스트 주도 개발 방법도 유용하다.
- 테스트 코드도 애플리케이션 코드와 마찬가지로 적절한 리팩토링이 필요하다.
- @Before, @After를 사용해서 테스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다.
- 동일한 설정파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.
- @Autowired를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI할 수 있다.
- 기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성하자.
- 오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용하다.
