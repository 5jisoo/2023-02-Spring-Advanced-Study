# Unit Testing

## 단위 테스트 (Unit Test)

**단위 테스트 (Unit Test)**는 코드의 작은 단위에 대해 테스트를 수행하는 것이다. "단위"의 크기는 엄격하게 정의되진 않지만, 주로 하나의 기능이나 관심 영역에 집중하여 효과적으로 테스트할 수 있는 범위다. 특히, 외부 리소스(예: 데이터베이스)의 상태가 테스트에 영향을 주지 않아야 한다.

단위 테스트를 하는 이유는 개발자가 자신이 작성한 코드가 의도한 대로 동작하는지를 빠르게 확인하기 위함이다. 자동 수행 가능한 테스트 코드를 작성하면, 반복적으로 테스트를 수행하여 코드를 빠르게 수정하고 확인할 수 있다.

## 테스트의 자동화

**자동 수행 가능한 테스트 코드**는 번거로운 작업 없이 빠르게 실행할 수 있는 장점이 있다. 코드 수정 후 테스트를 즉시 수행하여 결과를 확인할 수 있기 때문에 개발 생산성을 향상시킨다. 이를 통해 점진적인 개발과 지속적인 개선이 가능해진다.

테스트 주도 개발 (TDD)는 의도된 기능에 대한 테스트를 먼저 작성한 후, 해당 테스트를 통과할 수 있도록 코드를 작성하는 개발 방법론이다. 이를 통해 안정적이고 견고한 코드를 구현할 수 있다.

## UserDaoTest의 문제점

`UserDaoTest`의 문제점은 수동 확인 및 실행 작업이 번거로워진다는 것이다. 테스트 코드를 실행하고 결과를 직접 확인하는 과정이 수동으로 이루어져야 하므로 효율성이 떨어진다.

## UserDaoTest의 개선

### 1. 테스트 검증의 자동화

테스트 코드를 자동화하여 `UserDao`의 `get` 및 `add` 기능이 정상적으로 동작하는지를 손쉽게 확인할 수 있도록 변경할 수 있다.

```java
@Test
public void addAndGet() throws SQLException, ClassNotFoundException {
        ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
        UserDao dao = context.getBean("userDao", UserDao.class);
        dao.deleteAll();
        assertThat(dao.getCount(), is(0));

        User user = new User("gyumee", "박상철", "springno1");
        dao.add(user);
        assertThat(dao.getCount(), is(1));

        User user2 = dao.get(user.getId());
        assertThat(user2.getName(), is(user.getName()));
        assertThat(user2.getPassword(), is(user.getPassword()));
        }
```

### 2. 테스트의 효율적인 수행과 결과 관리

기존의 `main` 메소드에서 수행되던 테스트 코드를 `addAndGet` 등으로 메소드로 옮기고, JUnit을 활용하여 테스트를 효율적으로 수행할 수 있도록 변경한다.

```java
@Test
public void addAndGet() throws SQLException, ClassNotFoundException {
        ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
        UserDao dao = context.getBean("userDao", UserDao.class);
        dao.deleteAll();
        assertThat(dao.getCount(), is(0));

        User user = new User("gyumee", "박상철", "springno1");
        dao.add(user);
        assertThat(dao.getCount(), is(1));

        User user2 = dao.get(user.getId());
        assertThat(user2.getName(), is(user.getName()));
        assertThat(user2.getPassword(), is(user.getPassword()));
        }
```

### 3. `deleteAll` 및 `getCount` 추가

새로운 기능인 `deleteAll` 및 `getCount`를 추가하여 테스트 코드를 확장한다.

```java
@Test
public void deleteAllAndGetCount() throws SQLException, ClassNotFoundException {
        ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
        UserDao dao = context.getBean("userDao", UserDao.class);

        dao.deleteAll();
        assertThat(dao.getCount(), is(0));

        User user1 = new User("gyume1", "진양철", "no123");
        User user2 = new User("gyume2", "진도준", "no124");
        User user3 = new User("gyume3", "진비비", "no125");

        dao.add(user1);
        assertThat(dao.getCount(), is(1));

        dao.add(user2);
        assertThat(dao.getCount(), is(2));

        dao.add(user3);
        assertThat(dao.getCount(), is(3));
        }
```

## 학습 테스트 예제

JUnit 테스트 오브젝트에 대한 학습 테스트 코드를 작성하여 테스트의 완성도를 높이고 버그를 신속하게 해결할 수 있다.

```java
@Test
public void learningTest() {
        assertThat(testObjects, not(hasItem(this)));
        testObjects.add(this);

        assertThat(contextObject == null || contextObject == this.context, is(true));
        contextObject = this.context;
        }
```

## 결론

작은 단위의 테스트는 코드의 신뢰성을 높이고 버그를 빠르게 발견하는 데에 중요한 역할을 한다. 자동 수행 가능한 테스트 코드를 통해 개발자는 더 빠르게 코드를 수정하고 확인할 수 있으며, 이는 전체적인 소프트웨어의 품질을 향상시킨다. 학습 테스트와 버그 테스트는 테스트의 완성도를 높이고 기술적인 문제를 해결하는 데 도움이 된다.

# JUnit

### 2.3.1 JUnit 테스트 실행 방법

가장 좋은 JUnit 테스트 실행 방법은 자바 IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것이다.

**IDE를 통한 실행:**
- IDE를 통해 JUnit 테스트의 실행과 결과를 확인하는 방법은 간단하고 직관적이다.
- 테스트 결과를 손쉽게 확인할 수 있으며, 소스와 긴밀하게 연동돼서 결과를 확인할 수 있다.

**빌드 툴을 이용한 실행:**
- 여러 개발자가 만든 코드를 모두 통합해야 할 때 서버에서 코드를 가져와 통합하고 빌드한 뒤에 테스트를 수행하는 것이 좋다.
- 빌드 스크립트를 이용해 JUnit 테스트를 실행하고 결과를 메일 등으로 통보받는 방법을 사용하면 된다.

### 2.3.2 테스트 결과의 일관성

테스트는 외부 상태에 의존하지 않고 일관된 결과를 가져야 한다. 이를 위해 DB 초기화가 필요하다.

**deleteAll() 및 getCount() 추가:**
```java
public void deleteAll() throws SQLException {
    // USER 테이블의 모든 레코드를 삭제
    // ...
}

public int getCount() throws SQLException {
    // USER 테이블의 레코드 개수를 반환
    // ...
}
```

**테스트 코드 예시:**
```java
@Test
public void deleteAllAndGetCount() throws SQLException, ClassNotFoundException {
    UserDao dao = new UserDao();
    dao.deleteAll();
    assertThat(dao.getCount(), is(0));

    // 추가적인 테스트 케이스 작성
    // ...
}
```

### 2.3.3 포괄적인 테스트

**getCount() 테스트 확장:**
```java
@Test
public void getCount() throws SQLException {
    UserDao dao = new UserDao();
    
    // 추가적인 테스트 케이스 작성
    // ...
}
```

**get() 및 deleteAll() 테스트 보완:**
```java
@Test
public void addAndGet() throws SQLException {
    UserDao dao = new UserDao();
    
    // 추가적인 테스트 케이스 작성
    // ...
}

@Test
public void getUserFailure() {
    UserDao dao = new UserDao();
    
    // 존재하지 않는 회원을 조회할 때의 예외조건 테스트 작성
    // ...
}
```

### 2.3.4 테스트가 이끄는 개발

**TDD (Test Driven Development):**
- 테스트 코드를 먼저 작성하고, 테스트가 실패하는 것을 확인한 뒤 코드를 작성하는 방식이다.
- 테스트 코드는 기능 설계의 일부를 담고 있으며, 작성한 코드에 대한 확신을 가질 수 있게 해준다.

**장점:**
- 테스트를 먼저 작성하고 성공시키는 코드를 만드는 주기를 짧게 가져가므로 효율적이다.
- 테스트를 통한 피드백을 빠르게 받을 수 있어 자신감과 마음의 여유를 제공한다.

### 2.3.5 테스트 코드 개선

**@Before를 활용한 테스트 코드 개선:**
- JUnit은 각 테스트 메소드가 서로 독립적으로 실행되기 위해 매번 새로운 오브젝트를 만들게 한다.
- @Before 메소드를 활용하여 공통적인 테스트 준비 작업을 수행할 수 있다.
- 픽스처(테스트를 위한 정보나 오브젝트)를 생성하고 테스트 메소드에서 활용할 수 있도록 한다.

```java
public class UserDaoTest {
    private UserDao dao;

    @Before
    public void setUp() {
        dao = new UserDao();
    }

    // 테스트 메소드들...
}
```

위와 같이 개선된 테스트 코드는 테스트의 일관성과 유지보수성을 향상시킨다.