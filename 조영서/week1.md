# 1장 오브젝트와 의존관계

스프링을 이해하려면 먼저 오브젝트를 이해해야 한다. 오브젝트에 대한 관심은 오브젝트 설계로 발전한다. 스프링이 이 설계에 대한 명쾌한 기준을 마련해준다.

따라서 1장에서는 오브젝트의 설계, 구현, 동작 원리에 더 학습 목표를 맞춘다.

## 1.1 초난감 DAO

- DAO(Data Access Object) : DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트
- 사용자 정보를 저장할 때는 JavaBean 규약을 따르는 오브젝트를 이용하면 편리하다.
- JavaBean : Bean이라고도 부르는데 아래 두 가지 관례를 따라 만들어진 오브젝트를 가리킨다.
    - 디폴트 생성자 : JavaBean은 파라미터가 없는 디폴트 생성자를 가지고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
    - 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 setter와 getter을 이용해 수정/조회 할 수 있다.
- main() 을 이용하여 DAO 테스트 코드를 작성할 수 있다.
    - 모든 클래스에는 자신을 entry point로 설정해 직접 실행이 가능하게 해주는 static 메소드 main()이 있다.
    - 실패했을 경우에는 DB 설정, Connection 정보, 테이블 등록 여부, DB의 드라이버가 classpath에 존재하는지 여부를 확인해볼 수 있다.

## 1.2 DAO의 분리

객체지향 기술은 실세계를 최대한 가깝게 모델링 해낼 수 있기 때문에 의미가 있다고 여겨지지만, 실제로는 그보다 객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경/발전/확장시킬 수 있다는 것이 더 의미 있다.

개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 미래의 변화를 어떻게 대비할 것인가이다.

가장 좋은 대책은 최소한만 변화하는 것이다. 이를 위해 ”분리와 확장”을 고려하여 설계해야 한다.

- 분리
    
    모든 변경과 발전은 한 번에 1가지 관심 사항에 집중하여 일어난다. 그렇다면 우리는 한 가지 관심이 한 군데에 집중되게 해야 한다. 같은 관심끼리만 모으는 일이다.
    
    프로그램의 기초 개념 중 “관심사의 분리”를 떠올릴 수 있다. 관심이 같은 것끼리는 하나의 객체 안이나 친한 객체로 모이게 하고, 관심이 다른 것은 따로 떨어지게 하여 서로 영향을 주지 않도록 분리하는 것이다.
    
    예를 들면 DB 커넥션을 가져오는 코드가 여기저기에 중복돼서 나타나지 않도록 하는 것이다. 이후에 DB 드라이버 클래스나 URL이 변경되었을 때 1번만 수정하게 하기 위해서 이다.
    
    이렇게 기존의 코드를 외부의 동작 방식에는 변화가 없도록 하면서 내부 구조는 변경하는 작업을 refactoring이라고 한다.
    
    그중에서도 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 것을 메소드 추출 기법이라고 한다.
    
- 확장
    
    “상속을 통한 확장”이 있는데, 메소드 코드는 없지만 메소드 자체는 존재하는 추상 메소드를 만들어 이를 이룰 수 있다.
    
    숨기고 싶은 클래스는 구현 코드를 제거하여 추상 메소드로 바꾼다. 그 메소드의 구현은 서브 클래스가 담당하게 된다. 이후 추상 메소드를 상속하는 방법으로 확장이 이루어진다. 
    
    이렇게 슈퍼클래스에 기본적인 로직의 흐름을 만들고 그 기능의 일부를 추상 메소드나 protected 메소드 등으로 만든 후 서브 클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하는 방법을 “템플릿 메소드 패턴”이라고 한다.
    
    서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 “팩토리 메소드 패턴”이라고 한다.
    
    이렇게 되면 슈퍼클래스는 어떤 기능을 사용한다는 데에만 관심이 있고, 서브클래스는 어떤 식으로 기능을 제공하는지, 어떤 방법으로 오브젝트를 만들어내는지에 관심을 두고 있게 되는 것이다.
    
- 디자인 패턴
    
    SW 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말한다. 객체 지향적 설계 원칙을 이용해 문제를 해결한다. 대부분 클래스 상속이나 오브젝트 합성으로 확장성을 추구한다.
    
- 템플릿 메소드 패턴
    
    상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 방법이다. 
    
    변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다. 슈퍼클래스에서는 미리 추상 혹은 오버라이드 가능한 메소드를 정의해두고 이를 활용하여 템플릿 메소드를 만든다. 이렇게 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워두었다가 서브클래스에서 선택적으로 오버라이드 할 수 있도록 만들어둔 메소드를 hook 메소드라고 한다. 서브 클래스에서는 추상 메소드를 구현하거나 hook 메소드를 오버라이드 하는 방법을 이용해 기능을 확장한다. 기본 알고리즘 골격을 담은 메소드는 템플릿 메소드라고 한다.
    
- 팩토리 메소드 패턴
    
    상속을 통해 기능을 확장하게 하는 패턴이다.
    
    슈퍼클래스 코드에서는 서브클래스에서 구현할 메소들르 호출하여 필요한 타입의 오브젝트를 가져와 사용한다. 서브클래스는 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의 할 수 있다.
    

## 1.3 DAO의 확장

- 클래스의 분리
    
    둘 다 다른 코드를 더 강력하게 분리하기 위해 별도의 클래스를 만든다. 그럼 A 클래스에서 new 키워드를 사용하여 B 클래스의 오브젝트를 만들어 두고 이를 add(), get() 메소드로 사용하면 된다. 이때 B 클래스의 오브젝트는 한 번만 생성하여 저장해두고 계속 사용하는 것이 좋다.
    
    이렇게 되면 A가 변경이 될 수 있는 정보를 많이 알기 때문에 수정이 필요할 경우 코드 변경을 많이 해주어야 한다. 따라서 A가 기능을 가져오는 구체적인 방법에 종속되어 버려 자유롭게 확장하기 어려워진다.
    
- 인터페이스의 도입
    
    클래스를 분리하면서도 위의 문제를 해결하기 위해서 중간에 인터페이스를 생성해줄 수 있다. 인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보를 모두 감춘다. 즉 자신이 어떤 일을 하겠다는 기능만 정의해둔 것이다. 따라서 인터페이스를 통해 접근하게 되면 실제 구현 클래스를 바꿔도 신경 쓰지 않아도 된다.
    
- 관계설정 책임의 분리
    
    하지만 인터페이스와 함께 클래스 이름까지 알아야 한다는 문제가 생긴다. 왜냐하면 미처 분리하지 못한 또 다른 관심사항이 있기 때문이다. 바로 A와 A가 사용할 C의 특정 구현 클래스 사이의 관계를 설정해주는 것이다.
    
    (여기서 한가지, 사용되는 오브젝트는 서비스라고 부르고, 사용하는 오브젝트는 클라이언트라고 부른다.)
    
    그럼 위  관심사항을 분리하여 두기에 적절한 곳은 A의 클라이언트 오브젝트가 된다.
    
    따라서 우리는 오브젝트와 오브젝트 사이의 관계를 설정해주어야 한다. 이를 위해서는 만들어진 오브젝트가 필요한데 직접 생성자를 호출하여 만들 수 있지만 외부에서 만들어준 것을 가져올 수도 있다. (외부에서 만들어준 것을 전달 받으려면 메소드 파라미터나 생성자 파라미터를 이용할 수 있다.) 코드에서는 특정 클래스를 전혀 알지 못하여도 C의 클래스가 구현한 인터페이스를 사용했다면 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다. 다형성 덕분이다.
    
    덧붙여 아까 적절한 곳이라 불렀던 A의 클라이언트는 런타임 오브젝트 관계를 갖도록 만들어주어야 한다. 기존에는 A의 생성자가 자신이 사용할 오브젝트를 직접 만들어 자신과 관계를 만들어야 했지만 이렇게 되면 확장성을 떨어뜨리는 문제가 발생한다. 따라서 A의 클라이언트가 특정 구현 클래스를 선택하고 선택한 클래스의 오브젝트를 생성하여 A와 연결해주어야 한다. 
    
    그러기 위해서는 A의 생성자를 수정하여 클라이언트가 미리 만들어둔 C의 오브젝트를 전달 받을 수 있도록 파라미터를 하나 추가하게 되면 위에서 클래스 이름까지 알아야 하는 문제가 해결된다. 그렇게 되면 A의 클라이언트에 오브젝트를 만드는 코드가 생긴다. 이렇게 되면 A의 코드 수정 없이도 기능의 확장이 가능하다.
    
- 객체지향 설계 원칙 (SOLID)
    - 예외는 있겠지만 대부분의 상황에 잘 들어맞는 가이드라인
    - 디자인 패턴이 특별한 상황에서 발생하는 문제에 대한 구체적인 솔루션이라면 객체지향 설계 원칙은 일반적인 상황에서 적용 가능한 설계 기준이라고 할 수 있다.
    - 따라서 객체지향 디자인 패턴은 객체지향 설계 원칙을 잘 지켜져 만들어져 있다.
    - SRP = 단일 책임 원칙 = The Single Responsibility Principle
    - OCP = 개방 폐쇄 원칙 = The Open Closed Principle
    - LSP = 리스코프 치환 원칙 = The Liskov Substitution Priciple
    - ISP = 인터페이스 분리 원칙 = The Interface SEgreation Principle
    - DIP = 의존관계 역전 원칙 = The Dependency inversion Principle
- 원칙과 패턴
    - 개방 폐쇄 원칙 = OCP = Open-Closed Priciples
        - 객체지향 설계 원칙 중 하나
        - 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다
        - 위의 예시에서 A가 그렇다고 할 수 있다. 기능 확장에는 열려 있으나 코드 변경 없이도 그런 확장이 유지가 가능하기 때문이다.
    - 높은 응집도와 낮은 결합도 = high coherence and low coupling
        - 개방 폐쇄 원칙은 높은 응집도와 낮은 결합도라는 원리로도 설명이 가능하다
        - 높은 응집도
            - 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다
            - 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 뜻이다
        - 낮은 결합도
            - 하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도가 낮은 것
            - 관계를 유지하는 데에 꼭 필요한 최소한의 방법만 간접적인 형태로 제공한다.
            - 대신 나머지는 서로 독립적이고 알 필요도 없게 만들어 준다.
            - 변화에 대응하는 속도가 높고, 구성이 깔끔해지고, 확장하기에도 편리해진다.
            - 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도를 유지하는 것이 바람직하다.
        - 위에서 A와 C는 각각 높은 응집도를 가지지만 A와 C는 서로 낮은 결합도를 가진다.
- 전략 패턴
    - 개방 폐쇄 원칙에 가장 잘 들어맞는 패턴
    - 자신의 기능 맥락(컨텍스트)에서 필요에 따라 변경이 필요한 알고리즘(독립적으로 책임 분리가 가능한 기능)을 인터페이스를 통째로 외부로 분리시키고 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
    - 위의 A가 전략 패턴의 컨텍스트에 해당된다.
- 따라서 위의 A는 개방 폐쇄 원칙, 높은 응집력과 낮은 결합도, 전략 패턴을 모두 적용한 예시이다.

## 1.4 제어의 역전(IoC)

- 오브젝트 팩토리
    
    위의 UserDao의 클라이언트인 UserDaoTest는 얼떨결에 어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 기능까지 떠맡게 되었다. 이를 분리해주어야 한다.
    
    - 팩토리
        - 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 오브젝트
        - 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하기 위해 사용한다
        - DaoFactory라고 명명하고 UserDaoTest에 있던 UserDao, ConnectonMaker 관련 생성 작업을 DaoFactory로 옮긴다. UserDaoTest에는 DaoFactory에 요청해서 미리 만들어진 UserDao 오브젝트를 가져와 사용하게 한다. UserDaoTest는 이제 UserDao가 어떻게 만들어지는지, 어떻게 초기화되어 있는지에 신경 쓰지 않아도 된다.
    - 설계도로서의 팩토리
        - 결국 UserDao와 ConnectionMaker은 각각 애플리케이션의 핵심적인 데이터 로직과 기술 로직을 담당하게 된다.
        - DaoFactory는 이런 애플리케이션의 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맡고 있다. 또한 설계도 역할을 하기도 하는데 어떤 오브젝트가 어떤 오브젝트를 사용하는지를 정의해놓은 코드가 된다.
        - 이제 N사와 D사에 UserDao를 공급할 때 UserDao, ConnectionMaker, DaoFactory를 제공한다. DaoFactory는 소스만 제공한다. 이후 새로운 ConnectionMaker 구현 클래스로 변경이 필요하면 DaoFactory를 수정하면 된다. UserDao는 변경할 필요가 없다는 것이 핵심이다.
- 오브젝트 팩토리의 활용
    - 만약 UserDao 이외에 AccountDao, MessageDao를 만든다면 ConnectionMaker 구현 클래스를 선정하고 생성하는 코드가 중복된다. 이를 또 분리해주는 리팩토링 작업을 해야 한다.
- 제어권의 이전을 통한 제어관계 역전 (IoC)
    - 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지도 생성하지도 않는다.
    - 모든 제어 권한이 자신이 아닌 다른 대상에게 위임되기 때문이다.
    - 생각보다 흔하게 사용이 되는데 제어권을 상위 템플릿 메소드에 넘기고 자신은 필요할 때 호출되어 사용되도록 하는 것이 제어관계 역전이기 때무이다. 이때 템플릿 메소드는 제어의 역전이라는 개념을 활용해 문제를 해결하는 디자인 패턴이다.
    - 프레임워크도 제어의 역전 개념이 적용된 기술이다. 프레임워크는 애플리케이션 코드가 프레임워크에 의해 사용된다. (라이브러리를 사용하는 애플리케이션 코든느 애플리케이션 흐름을 직접 제어한다.)
    - 위 예시에서 UserDao가 팩토리에 의해 수동적으로 만들어지고 자신이 사용할 오브젝트도 DaoFactory가 공급해주는 것을 수동적으로 사용해야 하는 입장이기 때문에 제어의 역전이 적용되어 있다고 볼 수 있다.
    - IoC에서는 관장하는 존재가 필요한데 DaoFacotry가 오브젝트 수준의 가장 단순한 IoC 컨테이너(프레임워크)라고 할 수 있다.
    - IoC를 적용하면 설계가 깔끔해지고, 유연성이 증가하고, 확장성이 좋아진다.

## 1.5 스프링의 IoC

- 오브젝트 팩토리를 이용한 스프링 IoC
    - Bean : 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트, 오브젝트 단위의 애플리케이션 컴포넌트, 스프링이 IoC 방식으로 관리하는 오브젝트
    - Spring Bean : 제어의 역전이 적용된 오브젝트
    - Bean factory : 빈의 제어를 담당하는 IoC 오브젝트, 스프링의 IoC를 담당하는 핵심 컨테이너, 빈을 등록/생성/조회/리턴 등의 관리를 한다
    - Application context : Bean Factory를 확장한 IoC 컨테이너, Bean Factory와 같이 쓰인다, 제어 작업을 총괄한다, 위에서 나온 설계도를 의미한다, Bean Factory를 상속한다.
        - Bean factory라고 하면 Bean의 생성과 제어 관점에서 이야기 하는 것이고 Application Context라고 하면 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기 하는 것이다.
    - 설정 정보/설정 메타 정보 : IoC를 적용하기 위해 사용하는 메타정보
    - (IoC) 컨테이너 : Application context보다 추상적인 표현
- DaoFactory를 사용하는 애플리케이션 컨텍스트
    - @Configuration 어노테이션을 통해 빈 팩토리를 위한 오브젝트 설정을 담당한 클래스라고 스프링에게 인식시킨다.
    - 오브젝트를 만드는 메소드에는 @Bean 어노테이션을 붙여준다.
    - 따라서 DaoFactory에 @Configuration을, userDao와 connectionMaker에 @Bean을 붙여준다. 이후 AnnotationConfigApplicationContext를 이용해 @Configuration이 붙은 자바 코드를 설정 정보로 사용할 수 있도록 해주고 getBean() 메소드를 통해 UserDao의 오브젝트를 가져온다. 이 말은 userDao()를 호출하여 그 결과를 가져온다는 뜻이다.
    - getBean() 메소드는 기본적으로 Object 타입을 리턴해서 매번 다시 캐스팅을 해주어야 한다. 따라서 제네릭 메소드를 사용해 getBean()의 파라미터에 리턴 타입을 주면 캐스팅을 하지 않아도 된다.
- 애플리케이션 컨텍스트의 동작방식
    - 오브젝트 팩토리 = 애플리케이션 컨텍스트 = IoC 컨테이너  = 스프링 컨테이너 = 빈 팩토리
    - 애플리케이션 컨텍스트는 DaoFactory 클래스를 설정정보로 등록한다 → @Bean이 붙은 메소드 이름을 가져와 빈 목록을 만든다 → 클라이언트가 애플리케이션 컨텍스트의 getBean() 메소드를 호출하면 빈 목록에서 찾는다 → 있다면 빈을 생성하는 메소드를 호출하여 오브젝트를 생성시킨 후 클라이언트에게 돌려준다.
    - 애플리케이션 컨텍스트를 사용할 때의 장점
        - 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
        - 종합 IoC 서비스를 제공한다.
        - 빈을 검색하는 다양한 방법을 제공한다.

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

- 오브젝트의 동일성과 동등성
    - 동일성 : 같은 오브젝트, == 연산자를 사용하여 비교한다
    - 동등성 : 동일한 정보를 담고 있는 오브젝트, equals() 메소드를 이용해 비교한다.
    - 스프링은 여러번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다. 매번 new에 의해 새로운 UserDao가 만들어지지 않는다.
- 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
    - 스프링은 기본적으로 빈 오브젝트를 모두 싱글톤으로 만든다. 서버 환경에서 주로 스프링이 적용되기 때문이다. 그래야 부하를 덜 수 있다.
    - 싱글톤 패턴의 한계
        - private 생성자를 갖고 있기 때문에 상속할 수 없다
        - 테스트하기 어렵다
        - 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다
        - 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다
    - 싱글톤 레지스트리
        - 직접 싱글톤 형태의 오브젝틀르 만들고 관리하는 기능
        - public 생성자를 가질 수 있다. 간단히 오브젝트를 생성하여 사용할 수 있다. 테스트 환경에서 자유롭게 오브젝트를 만들 수 있다. 생성자 파라미터로 오브젝트를 넣어줄 수도 있다.
- 싱글톤과 오브젝트의 상태
    - 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 무상태 방식으로 만들어져야 한다. 다중 사용자들이 한 번에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 것이 위험하기 때문이다. 생성한 정보는 파라미터, 로컬 변수, 리턴 값을 이용하여 다룰 수 있다.
- 스프링 빈의 스코프
    - 빈이 생성되고 존재하고 적용되는 범위
    - 기본 스코프는 싱글톤이다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다.
    - 추가로 프로토타입 스코프도 있다. 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어온다.

## 1.7 의존관계 주입(DI)

- 런타임 의존관계 설정
    - 의존 관계 : 항상 방향성이 있다. A가 B에 의존한다는 것은 B가 변하면 A에도 영향을 미친다는 뜻이다.
    - 그러나 인터페이스를 통해 의존관계에 제한을 주면 변경에서 자유로워지기도 한다.
    - 의존 관계 주입
        - 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.
        - 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
        - 의존관게는 사용할 오브젝트에 대한 레퍼런스를 외부에서 주입해줌으로써 만들어진다.
- 의존관계 검색과 주입
    - 의존 관계 검색 : 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 자신이 어떤 클래스의 오브젝트를 이용할진 결정하지는 않는다.

## 1.8 XML을 이용한 설정

- XML 설정
    - 스프링 애플리케이션 컨텍스트는 XML에 담긴 DI 정보를 활용할 수 있다.
    - @Bean 메소드를 이용해 얻을 수 있는 빈의 DI 정보는 빈의 이름, 클래스, 의존 오브젝트이다.
- 프로퍼티 값의 주입
    - 수정자 메소드에는 다른 빈이나 오브젝트, 스트링 같은 값들을 넣어줄 수 있다. 클래스 코드를 수정할 필요가 없게 하기 위함이다.
