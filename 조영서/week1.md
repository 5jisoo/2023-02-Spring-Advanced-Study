# 1장 오브젝트와 의존관계

스프링을 이해하려면 먼저 오브젝트를 이해해야 한다. 오브젝트에 대한 관심은 오브젝트 설계로 발전한다. 스프링이 이 설계에 대한 명쾌한 기준을 마련해준다.

따라서 1장에서는 오브젝트의 설계, 구현, 동작 원리에 더 학습 목표를 맞춘다.

## 1.1 초난감 DAO

- DAO(Data Access Object) : DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트
- 사용자 정보를 저장할 때는 JavaBean 규약을 따르는 오브젝트를 이용하면 편리하다.
- JavaBean : Bean이라고도 부르는데 아래 두 가지 관례를 따라 만들어진 오브젝트를 가리킨다.
    - 디폴트 생성자 : JavaBean은 파라미터가 없는 디폴트 생성자를 가지고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
    - 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 setter와 getter을 이용해 수정/조회 할 수 있다.
- main() 을 이용하여 DAO 테스트 코드를 작성할 수 있다.
    - 모든 클래스에는 자신을 entry point로 설정해 직접 실행이 가능하게 해주는 static 메소드 main()이 있다.
    - 실패했을 경우에는 DB 설정, Connection 정보, 테이블 등록 여부, DB의 드라이버가 classpath에 존재하는지 여부를 확인해볼 수 있다.

## 1.2 DAO의 분리

객체지향 기술은 실세계를 최대한 가깝게 모델링 해낼 수 있기 때문에 의미가 있다고 여겨지지만, 실제로는 그보다 객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경/발전/확장시킬 수 있다는 것이 더 의미 있다.

개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 미래의 변화를 어떻게 대비할 것인가이다.

가장 좋은 대책은 최소한만 변화하는 것이다. 이를 위해 ”분리와 확장”을 고려하여 설계해야 한다.

- 분리
    
    모든 변경과 발전은 한 번에 1가지 관심 사항에 집중하여 일어난다. 그렇다면 우리는 한 가지 관심이 한 군데에 집중되게 해야 한다. 같은 관심끼리만 모으는 일이다.
    
    프로그램의 기초 개념 중 “관심사의 분리”를 떠올릴 수 있다. 관심이 같은 것끼리는 하나의 객체 안이나 친한 객체로 모이게 하고, 관심이 다른 것은 따로 떨어지게 하여 서로 영향을 주지 않도록 분리하는 것이다.
    
    예를 들면 DB 커넥션을 가져오는 코드가 여기저기에 중복돼서 나타나지 않도록 하는 것이다. 이후에 DB 드라이버 클래스나 URL이 변경되었을 때 1번만 수정하게 하기 위해서 이다.
    
    이렇게 기존의 코드를 외부의 동작 방식에는 변화가 없도록 하면서 내부 구조는 변경하는 작업을 refactoring이라고 한다.
    
    그중에서도 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 것을 메소드 추출 기법이라고 한다.
    
- 확장
    
    “상속을 통한 확장”이 있는데, 메소드 코드는 없지만 메소드 자체는 존재하는 추상 메소드를 만들어 이를 이룰 수 있다.
    
    숨기고 싶은 클래스는 구현 코드를 제거하여 추상 메소드로 바꾼다. 그 메소드의 구현은 서브 클래스가 담당하게 된다. 이후 추상 메소드를 상속하는 방법으로 확장이 이루어진다. 
    
    이렇게 슈퍼클래스에 기본적인 로직의 흐름을 만들고 그 기능의 일부를 추상 메소드나 protected 메소드 등으로 만든 후 서브 클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하는 방법을 “템플릿 메소드 패턴”이라고 한다.
    
    서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 “팩토리 메소드 패턴”이라고 한다.
    
    이렇게 되면 슈퍼클래스는 어떤 기능을 사용한다는 데에만 관심이 있고, 서브클래스는 어떤 식으로 기능을 제공하는지, 어떤 방법으로 오브젝트를 만들어내는지에 관심을 두고 있게 되는 것이다.
    
- 디자인 패턴
    
    SW 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말한다. 객체 지향적 설계 원칙을 이용해 문제를 해결한다. 대부분 클래스 상속이나 오브젝트 합성으로 확장성을 추구한다.
    
- 템플릿 메소드 패턴
    
    상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 방법이다. 
    
    변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다. 슈퍼클래스에서는 미리 추상 혹은 오버라이드 가능한 메소드를 정의해두고 이를 활용하여 템플릿 메소드를 만든다. 이렇게 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워두었다가 서브클래스에서 선택적으로 오버라이드 할 수 있도록 만들어둔 메소드를 hook 메소드라고 한다. 서브 클래스에서는 추상 메소드를 구현하거나 hook 메소드를 오버라이드 하는 방법을 이용해 기능을 확장한다. 기본 알고리즘 골격을 담은 메소드는 템플릿 메소드라고 한다.
    
- 팩토리 메소드 패턴
    
    상속을 통해 기능을 확장하게 하는 패턴이다.
    
    슈퍼클래스 코드에서는 서브클래스에서 구현할 메소들르 호출하여 필요한 타입의 오브젝트를 가져와 사용한다. 서브클래스는 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의 할 수 있다.
    

## 1.3 DAO의 확장

- 클래스의 분리
    
    둘 다 다른 코드를 더 강력하게 분리하기 위해 별도의 클래스를 만든다. 그럼 A 클래스에서 new 키워드를 사용하여 B 클래스의 오브젝트를 만들어 두고 이를 add(), get() 메소드로 사용하면 된다. 이때 B 클래스의 오브젝트는 한 번만 생성하여 저장해두고 계속 사용하는 것이 좋다.
    
    이렇게 되면 A가 변경이 될 수 있는 정보를 많이 알기 때문에 수정이 필요할 경우 코드 변경을 많이 해주어야 한다. 따라서 A가 기능을 가져오는 구체적인 방법에 종속되어 버려 자유롭게 확장하기 어려워진다.
    
- 인터페이스의 도입
    
    클래스를 분리하면서도 위의 문제를 해결하기 위해서 중간에 인터페이스를 생성해줄 수 있다. 인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보를 모두 감춘다. 즉 자신이 어떤 일을 하겠다는 기능만 정의해둔 것이다. 따라서 인터페이스를 통해 접근하게 되면 실제 구현 클래스를 바꿔도 신경 쓰지 않아도 된다.
    
- 관계설정 책임의 분리
    
    하지만 인터페이스와 함께 클래스 이름까지 알아야 한다는 문제가 생긴다. 왜냐하면 미처 분리하지 못한 또 다른 관심사항이 있기 때문이다. 바로 A와 A가 사용할 C의 특정 구현 클래스 사이의 관계를 설정해주는 것이다.
    
    (여기서 한가지, 사용되는 오브젝트는 서비스라고 부르고, 사용하는 오브젝트는 클라이언트라고 부른다.)
    
    그럼 위  관심사항을 분리하여 두기에 적절한 곳은 A의 클라이언트 오브젝트가 된다.
    
    따라서 우리는 오브젝트와 오브젝트 사이의 관계를 설정해주어야 한다. 이를 위해서는 만들어진 오브젝트가 필요한데 직접 생성자를 호출하여 만들 수 있지만 외부에서 만들어준 것을 가져올 수도 있다. (외부에서 만들어준 것을 전달 받으려면 메소드 파라미터나 생성자 파라미터를 이용할 수 있다.) 코드에서는 특정 클래스를 전혀 알지 못하여도 C의 클래스가 구현한 인터페이스를 사용했다면 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다. 다형성 덕분이다.
    
    덧붙여 아까 적절한 곳이라 불렀던 A의 클라이언트는 런타임 오브젝트 관계를 갖도록 만들어주어야 한다. 기존에는 A의 생성자가 자신이 사용할 오브젝트를 직접 만들어 자신과 관계를 만들어야 했지만 이렇게 되면 확장성을 떨어뜨리는 문제가 발생한다. 따라서 A의 클라이언트가 특정 구현 클래스를 선택하고 선택한 클래스의 오브젝트를 생성하여 A와 연결해주어야 한다. 
    
    그러기 위해서는 A의 생성자를 수정하여 클라이언트가 미리 만들어둔 C의 오브젝트를 전달 받을 수 있도록 파라미터를 하나 추가하게 되면 위에서 클래스 이름까지 알아야 하는 문제가 해결된다. 그렇게 되면 A의 클라이언트에 오브젝트를 만드는 코드가 생긴다. 이렇게 되면 A의 코드 수정 없이도 기능의 확장이 가능하다.
    
- 객체지향 설계 원칙 (SOLID)
    - 예외는 있겠지만 대부분의 상황에 잘 들어맞는 가이드라인
    - 디자인 패턴이 특별한 상황에서 발생하는 문제에 대한 구체적인 솔루션이라면 객체지향 설계 원칙은 일반적인 상황에서 적용 가능한 설계 기준이라고 할 수 있다.
    - 따라서 객체지향 디자인 패턴은 객체지향 설계 원칙을 잘 지켜져 만들어져 있다.
    - SRP = 단일 책임 원칙 = The Single Responsibility Principle
    - OCP = 개방 폐쇄 원칙 = The Open Closed Principle
    - LSP = 리스코프 치환 원칙 = The Liskov Substitution Priciple
    - ISP = 인터페이스 분리 원칙 = The Interface SEgreation Principle
    - DIP = 의존관계 역전 원칙 = The Dependency inversion Principle
- 원칙과 패턴
    - 개방 폐쇄 원칙 = OCP = Open-Closed Priciples
        - 객체지향 설계 원칙 중 하나
        - 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다
        - 위의 예시에서 A가 그렇다고 할 수 있다. 기능 확장에는 열려 있으나 코드 변경 없이도 그런 확장이 유지가 가능하기 때문이다.
    - 높은 응집도와 낮은 결합도 = high coherence and low coupling
        - 개방 폐쇄 원칙은 높은 응집도와 낮은 결합도라는 원리로도 설명이 가능하다
        - 높은 응집도
            - 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다
            - 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 뜻이다
        - 낮은 결합도
            - 하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도가 낮은 것
            - 관계를 유지하는 데에 꼭 필요한 최소한의 방법만 간접적인 형태로 제공한다.
            - 대신 나머지는 서로 독립적이고 알 필요도 없게 만들어 준다.
            - 변화에 대응하는 속도가 높고, 구성이 깔끔해지고, 확장하기에도 편리해진다.
            - 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도를 유지하는 것이 바람직하다.
        - 위에서 A와 C는 각각 높은 응집도를 가지지만 A와 C는 서로 낮은 결합도를 가진다.
- 전략 패턴
    - 개방 폐쇄 원칙에 가장 잘 들어맞는 패턴
    - 자신의 기능 맥락(컨텍스트)에서 필요에 따라 변경이 필요한 알고리즘(독립적으로 책임 분리가 가능한 기능)을 인터페이스를 통째로 외부로 분리시키고 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
    - 위의 A가 전략 패턴의 컨텍스트에 해당된다.
- 따라서 위의 A는 개방 폐쇄 원칙, 높은 응집력과 낮은 결합도, 전략 패턴을 모두 적용한 예시이다.
